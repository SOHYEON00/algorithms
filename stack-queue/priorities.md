## 문제
### 문제 설명
일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 
그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 
이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 
이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.
<br>
![](https://images.velog.io/images/sohyeon00/post/9023982b-7b55-4cce-a025-ab3049ec228f/image.png)
예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.

내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.

현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성하세요.

### 제한 조건
현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.
인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.
location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.


## 문제 풀이법
사실 해당 풀이법은 6점을 받은 그리 좋진 않은 코드이다.
리스트를 3개나 만들어 불필요한 메모리 낭비 발생이 생긴 듯하다. 빠른 시일 내에 추가로 코드작성해 올릴 예정!

***
### 아이디어 + 코드 설명
- 기존 priorities 리스트의 인덱스를 기억해야할 필요가 있다고 보였음. -> location을 찾기 위해.
그래서 기존 index만으로 구성된 리스트를 새로 선언 - ori_index 하고 priorities를 deque로 이용해 새로 deq을 선언함.
- deq에서 변동되는 모든 것들을 ori_index에서도 같이 적용할 예정

![](https://images.velog.io/images/sohyeon00/post/264d8ee1-d78c-43f8-ab00-4e5dcdf30df6/image.png)

- deq[0]을 first라고 하자.
first와 deq의 가장 큰 값, max(deq)을 비교했을 때,
	1. first가 max보다 값이 작다면
    deq.append(deq.popleft()) : first를 빼고 맨 뒤로 다시 넣는다.
    2. first가 max보다 크거나 같다면
    deq.popleft() : first값을 아예 빼버린다.
    이때, ori_index.popleft()값은 list_answer에 들어간다.
- 이 모든 과정은 ori_index에서도 같이 일어난다.

-list_index에는 기존 priorities의 인덱스값들이 우선순위에 맞게 프린터 작업된 순서가 들어가 있다.

<br>
***
<br>

### 리뷰
- 기존 배열의 index를 어떻게 효과적으로 기억할지에 대해 고민을 좀 오래했다. 지금 코드는 비효율적인 것 같아 조금 더 고민해 볼 예정. 꼭 리스트가 저렇게 필요하지 않은 것 같다.
- 문제 하나하나 풀 때마다 여러 아이디어들이 나온다.
무엇이 정답이다! 라고 하긴 어렵지만 원래 코딩엔 정답이 없는 거랬으니까 이것저것 효율성을 우선으로 고려해 시도해보면 좋은 것 같다. 
- 이리저리 번뜩이는 (과연 좋은 것인진 모르겠지만, 시도해볼만한 가치가 있는) 아이디어들을 제때에 명확한 문장으로 잘 정리해놓는 것도 연습이 필요하다고 느꼈다.

<br>
<br><br>


> 출처
https://programmers.co.kr/learn/courses/30/lessons/42587